 random sampling 

 + 1. Main function 

 + 2. Code implementation 

 + 3. Results display 

 + 4. CloudCompare 

 + 5. C++ version code 

#  First, the main function 

   The Python random sample () method returns a list of randomly selected items from the sequence. 

  ```python  
After clicking on the GitHub Sponsor button above, you will obtain access permissions to my private code repository ( https://github.com/slowlon/my_code_bar ) to view this blog code. By searching the code number of this blog, you can find the code you need, code number is: 2024020309574457323
  ```  
#  Code implementation 

  ```python  
After clicking on the GitHub Sponsor button above, you will obtain access permissions to my private code repository ( https://github.com/slowlon/my_code_bar ) to view this blog code. By searching the code number of this blog, you can find the code you need, code number is: 2024020309574457323
  ```  
#  III. Display of results 

 ![avatar]( 280b0fb2555d4c02962be5c61096a123.png) 

#  CloudCompare 

>  The algorithm is also integrated in CloudCCompare software. The implementation in CloudCompare software is as follows: 

 ![avatar]( 20201230092648371.gif) 

#  C++ version code 

 PCL random sampling 



--------------------------------------------------------------------------------

#  First, the main function 

   The Python random sample () method returns a list of randomly selected items from the sequence. 

  ```python  
After clicking on the GitHub Sponsor button above, you will obtain access permissions to my private code repository ( https://github.com/slowlon/my_code_bar ) to view this blog code. By searching the code number of this blog, you can find the code you need, code number is: 2024020309574467220
  ```  
#  Code implementation 

  ```python  
After clicking on the GitHub Sponsor button above, you will obtain access permissions to my private code repository ( https://github.com/slowlon/my_code_bar ) to view this blog code. By searching the code number of this blog, you can find the code you need, code number is: 2024020309574467220
  ```  
#  III. Display of results 

 ![avatar]( 280b0fb2555d4c02962be5c61096a123.png) 

#  CloudCompare 

>  The algorithm is also integrated in CloudCCompare software. The implementation in CloudCompare software is as follows: 

 ![avatar]( 20201230092648371.gif) 

#  C++ version code 

 PCL random sampling 



--------------------------------------------------------------------------------

#  I. Overview 

 ![avatar]( 22b58d839ec44675bf301f6903046352.png) 

   As the title, use the Open3D built-in function to assign color rendering to the point cloud based on the elevation of the point cloud. The result is shown in the figure below: In addition, any form of rendering effect can be selected according to the color distribution table. Attached: Assignment table 

#  Code implementation 

  ```python  
After clicking on the GitHub Sponsor button above, you will obtain access permissions to my private code repository ( https://github.com/slowlon/my_code_bar ) to view this blog code. By searching the code number of this blog, you can find the code you need, code number is: 2024020309574449348
  ```  
#  III. Display of results 

 ![avatar]( 9015969119164907afa5da4c0c6c3bba.png) 



--------------------------------------------------------------------------------

#  I. Overview 

   As the title, use the Python detailed process to assign color rendering to point clouds based on their elevation. 

#  Code implementation 

  ```python  
After clicking on the GitHub Sponsor button above, you will obtain access permissions to my private code repository ( https://github.com/slowlon/my_code_bar ) to view this blog code. By searching the code number of this blog, you can find the code you need, code number is: 2024020309574463399
  ```  
#  III. Display of results 

 ![avatar]( 63d567736826439ea7ab673eaac6a79d.png) 



--------------------------------------------------------------------------------

#  First, the principle of the algorithm 

##  1. Overview of the principle 

 ![avatar]( ed736b100a134ae69c7830210542c72b.png) 

   A point cloud is a collection of scattered points in space that represents the characteristic information of the surface contour of an object. Point cloud slicing is to use a set of planes to intersect the point cloud. Given a plane, a point cloud, find the contour line in the plane. Since the density of the point cloud is limited, it is not feasible to use the points in the plane to find the contour line. Therefore, the "bandwidth" is introduced, and the contour curve of the plane is generated by generating two equidistant plane sums in the normal vector direction. The distance between and is the bandwidth, and the bandwidth is the slice thickness. The point cloud slicing model is shown in the figure.  

##  2. References 

>  Yang Zhenqing, Yong Yonglei. Boundary extraction based on point cloud slice [J]. Computer Applications and Software, 2014, 31 (01): 222-224 + 245. 

##  3. Implementation process 

 ![avatar]( 3ecd9f7ff9e040c88259b953e2966d2e.png) 

   First, three points that are not collinear are selected from the point cloud, and then a plane is fitted according to the three points, and this plane is used as the tangent plane of the point cloud slice. As shown in the figure below:  

#  Code implementation 

  ```python  
After clicking on the GitHub Sponsor button above, you will obtain access permissions to my private code repository ( https://github.com/slowlon/my_code_bar ) to view this blog code. By searching the code number of this blog, you can find the code you need, code number is: 2024020309574458690
  ```  
#  III. Display of results 

 ![avatar]( 90cacbbecfd64a78b9eb0ed62df37e9f.png) 

#  C++ code 

 PCL point cloud slice 



--------------------------------------------------------------------------------

#  First, the principle of the algorithm 

##  1. Algorithm overview 

   ① Establish a horizontal grid according to the measurement range and number each grid unit; ② Project all data points vertically onto the grid. 

##  2. References 

>  Shi Wen, Li Bijun, Li Qingquan. Image segmentation method of vehicle laser scanning distance based on projection point density [J]. Chinese Journal of Surveying and Mapping, 2005 (02): 95-100. 

#  Code implementation 

  ```python  
After clicking on the GitHub Sponsor button above, you will obtain access permissions to my private code repository ( https://github.com/slowlon/my_code_bar ) to view this blog code. By searching the code number of this blog, you can find the code you need, code number is: 2024020309574497322
  ```  
#  III. Display of results 

 ![avatar]( a91249483f474c3497eed58ae657954b.png) 



--------------------------------------------------------------------------------

#  First, the principle of the algorithm 

##  1. Registration process 

   ICP iteratively corrects the rigid body transformation (translation, rotation) of the two original point clouds to minimize the distance between all point sets. Input: Two frames of original point clouds, initial estimate of the transformation, standard for stopping the iteration; Output: transformation matrix, modified point cloud after transformation. ICP algorithm steps: (1) For the point set 

 (4) Determine whether the convergence is based on the iteration error of the previous two iterations and the number of iterations.

     T0 = T0, repeat step (1). 

##  2. References 

>  [1] BESL P J, MCKAY N D. A method for registration of 3-Dshapes [J]. IEEE Transactions on Pattern Analysis and Machine Intelligence, 1992, 14 (2): 239-256. [2] Wang Fei, Liu Rufei, Ren Hongwei, Chai Yongning. Multi-phase vehicle laser point cloud registration using road target characteristics [J]. Journal of Surveying and Mapping Science and Technology, 2020, 37 (05): 496-502. 

#  Second, the main function 

 1. This class TransformationEstimationPointToPoint provides a function for computing the residuals and Jacobian matrix of the point-to-point ICP objective function. The function registration_icp take it as a parameter and run the point-to-point ICP to get the result. 2. The function evaluate_registration compute two main metrics. Fitness computes the overlapping area (interior point correspondence/number of target points). The higher the better. inlier_rmse computes the root mean square error RMSE for all intrinsic correspondence. The lower the better. 3. Since the function transformand paint_uniform_color changes the point cloud, the visualization part calls copy.deepcoy to replicate and protect the original point cloud. 

#  III. Code implementation 

  ```python  
After clicking on the GitHub Sponsor button above, you will obtain access permissions to my private code repository ( https://github.com/slowlon/my_code_bar ) to view this blog code. By searching the code number of this blog, you can find the code you need, code number is: 2024020309574429074
  ```  
#  IV. Display of results 

##  1. Initial position 

 ![avatar]( 20200828190129900.png) 

##  2. Registration results 

 ![avatar]( 2020082819022375.png) 

#  V. Reference links 

 1. Point-to-point ICP 2. Open3d learning plan - 9 (ICP registration) 3. Tutorial: Python Open3d completes ICP point cloud registration 



--------------------------------------------------------------------------------

#  First, the principle of the algorithm 

##  1. Algorithm overview 

>  Point-to-plane metrics are often solved using standard nonlinear least squares methods, such as Levenberg-Marquardt. Each iteration of the point-to-plane ICP algorithm is usually slower than that of the point-to-point algorithm, but the convergence rate is significantly faster. The relative rotation between the two point clouds is less than 30 °. Replace sintheta with theta in the rotation matrix, and replace costheta with 1 to achieve linear approximation of the nonlinear least squares optimization problem, speeding up the calculation. To improve the numerical stability of the calculation, a distance comparable to the size of the rotation angle needs to be used. The simplest approach is to re-scale and move the two input point clouds so that they are bounded within a unit sphere or cube centered on the origin. [1] 

##  2. Point-to-plane ICP precision registration 

 ![avatar]( 20210516145658292.png) 

   The traditional ICP algorithm adopts minimizing the distance between the corresponding points of the source point cloud and the target point cloud as the registration criterion, as shown in Figure (a). The point-to-plane ICP adopts minimizing the distance from the point in the source point cloud to the plane where the corresponding point in the target point cloud is located as the registration criterion, in which the transformation matrix is represented; the corresponding points in the source point cloud and the target point cloud are represented respectively; and the normal vector of the corresponding points is represented. Its principle is shown in Figure (b). Compared with the traditional ICP algorithm, the point-to-plane ICP can better reflect the spatial structure of the point cloud; can better resist erroneous corresponding point pairs; and has a faster iterative convergence speed.  

>  [2] Linear least squares optimization: pcl :: registration :: TransformationEstimationPointToPlaneLLS 

##  3. References 

>  [1] Low K L. Linear left-squares optimization for point-to-plane icp surface registration [J]. Chapel Hill, University of North Carolina, 2004, 4 (10): 1-3 [2] Efficient variants of the ICP algorithm Canada, 2001, pp.145-152 [3] Li Yuxiang, Guo Jiming, Pan Shangyi, Lu Lili, Lu Zhuxing, Zhang Di. A point cloud registration algorithm based on IS-SHOT features [J]. Surveying and Mapping Bulletin, 2020 (04): 21-26. [4] Point-to-plane ICP 

#  Second, the main function 

 1. This class TransformationEstimationPointToPlane () provides a function for computing the residuals of the ICP objective function opposite the point and the Jacobian matrix. The function registration_icp take it as a parameter and run the ICP opposite the point to get the result. 2. The function evaluate_registration compute two main metrics. Fitness computes the overlapping area (inner point correspondence/number of target points). The higher the better. inlier_rmse computes the root mean square error RMSE for all intrinsic correspondence. The lower the better. 3. Since the function transformand paint_uniform_color changes the point cloud, the visualization part calls copy.deepcoy to copy and protect the original point cloud. Rusinkiewicz2001 has shown that the point-to-point ICP algorithm has a faster convergence rate than the point-to-point ICP algorithm. 

#  III. Code implementation 

  ```python  
After clicking on the GitHub Sponsor button above, you will obtain access permissions to my private code repository ( https://github.com/slowlon/my_code_bar ) to view this blog code. By searching the code number of this blog, you can find the code you need, code number is: 2024020309574463552
  ```  
#  IV. Display of results 

 The test data used in this paper: Open3D algorithm test data.rar 

##  1. Initial position 

 ![avatar]( 20200828193630808.png) 

##  2. Registration results 

 ![avatar]( 20200828193704983.png) 



--------------------------------------------------------------------------------

#  First, the principle of the algorithm 

##  1. Nature 

 An ideal Poisson disk sampling point set needs to satisfy three conditions: 

   The sampling method that satisfies these three conditions is called maximized Poisson disc sampling. The effect after sampling is good, which can satisfy the uniform data points, retain the details better, and have better blue noise characteristics. The algorithm has a large time complexity 

##  2. Main functions 

  ```python  
After clicking on the GitHub Sponsor button above, you will obtain access permissions to my private code repository ( https://github.com/slowlon/my_code_bar ) to view this blog code. By searching the code number of this blog, you can find the code you need, code number is: 20240203095744630
  ```  
 The function samples points from the grid, where each point is approximately the same distance from its neighbors (blue noise). 

##  3. References 

>  [1] Quan Weize, Guo Jianwei, Zhang Yikuan, Meng Weiliang, Zhang Xiaopeng, Yan Dongming. Maximizing Poisson Disk Sampling Based on Sampling Radius Optimization [J]. China Science: Information Science, 2017, 47 (04): 442-454. [2] Sample Elimination for Generating Poisson Disk Sample Sets, EUROGRAPHICS, 2015. 

#  Code implementation 

  ```python  
After clicking on the GitHub Sponsor button above, you will obtain access permissions to my private code repository ( https://github.com/slowlon/my_code_bar ) to view this blog code. By searching the code number of this blog, you can find the code you need, code number is: 20240203095744630
  ```  
#  III. Display of results 

##  1. Grid model 

 ![avatar]( b4bfd65c1ea3476d929b5e6077cedd5c.png) 

##  2. Sampling results 

 ![avatar]( 8d013f0f43db4e959fe5c7816bedf8b8.png) 

##  3. Sampling results in point clouds 

 ![avatar]( b9bd7eb1118949968418b78797fc09d4.png) 



--------------------------------------------------------------------------------

#  First, the principle of the algorithm 

##   1. Algorithm overview 

   1. create_from_point_cloud_poisson function implements poisson surface reconstruction. An important parameter of the function is depth. It defines the depth of the octree used for surface reconstruction, so it means the resolution of the resulting triangle mesh. Higher depth values mean meshes with more detail. Note: This algorithm requires PointCloud to have normals.2. Poisson surface reconstruction also builds triangles in low-density areas, and even extrapolates to some areas. create_from_point_cloud_poisson function's second return value densities, indicating the density of each vertex. Low density values mean that vertices are supported only by a small number of points in the input point cloud. Therefore, low-supported vertices and triangles can be removed using density values. 

##   2. Function analysis 

  ```python  
After clicking on the GitHub Sponsor button above, you will obtain access permissions to my private code repository ( https://github.com/slowlon/my_code_bar ) to view this blog code. By searching the code number of this blog, you can find the code you need, code number is: 2024020309574473061
  ```  
 This function uses the original implementation of Kazhdan in "Kazhdan and Hoppe," Screened Poisson Surface Reconstruction ", 2013." See the implementation details: https://github.com/mkazhdan/PoissonRecon 

##   3. References 

>  [1] Kazhdan M , Bolitho M , Hoppe H . Poisson surface reconstruction. The Japan Institute of Energy, 2013. [2] Poisson surface reconstruction 

#  Code implementation 

  ```python  
After clicking on the GitHub Sponsor button above, you will obtain access permissions to my private code repository ( https://github.com/slowlon/my_code_bar ) to view this blog code. By searching the code number of this blog, you can find the code you need, code number is: 2024020309574473061
  ```  
#  III. Display of results 

 ![avatar]( 20201203083455913.png) 

 Reconstruction of the original point cloud possion surface, coloring according to density, deleting areas with low density  



--------------------------------------------------------------------------------

#  1. Quaternion to rotation matrix, code implementation 

  ```python  
After clicking on the GitHub Sponsor button above, you will obtain access permissions to my private code repository ( https://github.com/slowlon/my_code_bar ) to view this blog code. By searching the code number of this blog, you can find the code you need, code number is: 2024020309574447165
  ```  
##  4. Display of results 

>  Quaternion-to-rotation matrix; [[-0.6 -0.8 0.] [0.8 -0.6 0.] [0.0.1.]] 

#  Second, Euler angular rotation matrix 

##  3. Code implementation 

  ```python  
After clicking on the GitHub Sponsor button above, you will obtain access permissions to my private code repository ( https://github.com/slowlon/my_code_bar ) to view this blog code. By searching the code number of this blog, you can find the code you need, code number is: 2024020309574447165
  ```  
##  4. Display of results 

>  The Euler angle rotated 90 degrees along the X axis and 45 degrees along the Z axis is converted into a rotation matrix of [7.07106781e-01 -7.07106781e-01 0.000000e + 00] [4.32978028e-17 4.32978028e-17 -1.00000000e + 00] [7.07106781e-01 7.07106781e-01 6.12323400e-17]] 

#  Rotation vector to rotation matrix 

##  1. Rotation vector 

   For the rotation of a coordinate system, we know that any rotation can be characterized by an axis of rotation and an angle of rotation. Therefore, we can use a vector whose direction is consistent with the axis of rotation and whose length is equal to the angle of rotation. This vector is called a rotation vector (or axis angle, Axis-Angle). This representation requires only one three-dimensional vector to describe rotation. The purpose of this paper is to introduce the use of rotation vectors in open3d. The theoretical basis of rotation vectors will not be expanded in detail. Please refer to: Rotation Matrix and Rotation Vector 

##  2. Main functions 

   Open3d.geometry.get_rotation_matrix_from_axis_angle () implements the conversion of rotation vectors to rotation matrices. 

##  3. Code implementation 

  ```python  
After clicking on the GitHub Sponsor button above, you will obtain access permissions to my private code repository ( https://github.com/slowlon/my_code_bar ) to view this blog code. By searching the code number of this blog, you can find the code you need, code number is: 2024020309574447165
  ```  
##  4. Display of results 

>  The rotation vector rotated 45 degrees along the Z axis is converted into a rotation matrix of; [[0.70710678 -0.70710678 0.] [0.70710678 0.70710678 0.] [0.0.1.]] 



--------------------------------------------------------------------------------

#  First, the principle of the algorithm 

##  1. Overview of the principle 

 ![avatar]( 6f0f76e32d4344bc83f62f77fe8e8903.png) 

   The filtering idea of the radius filter is very straightforward, that is, in the point cloud data, set each point to have at least enough close neighbors within a certain radius, and it will be deleted if it is not satisfied. For example, if you specify a radius d, and then specify that there are at least 1 neighbor within the radius, then only the yellow points in the image below will be deleted from the point cloud. If you specify at least 2 neighbors within the radius, then both the yellow and green points will be deleted from the point cloud.  

##  2. Implementation process 

##  3. Main functions 

  ```python  
After clicking on the GitHub Sponsor button above, you will obtain access permissions to my private code repository ( https://github.com/slowlon/my_code_bar ) to view this blog code. By searching the code number of this blog, you can find the code you need, code number is: 2024020309574421044
  ```  
##  4. Algorithm source code 

  ```python  
After clicking on the GitHub Sponsor button above, you will obtain access permissions to my private code repository ( https://github.com/slowlon/my_code_bar ) to view this blog code. By searching the code number of this blog, you can find the code you need, code number is: 2024020309574421044
  ```  
##  5. References 

>  [1] Chen Hongyi, Hu Xiaobin, Li Chongrui. Application of ground 3D laser scanning technology in deformation monitoring [J]. Bulletin of Surveying and Mapping, 2014 (12): 74-77. 

#  Code implementation 

  ```python  
After clicking on the GitHub Sponsor button above, you will obtain access permissions to my private code repository ( https://github.com/slowlon/my_code_bar ) to view this blog code. By searching the code number of this blog, you can find the code you need, code number is: 2024020309574421044
  ```  
#  III. Display of results 

##  1. Primitive point cloud 

 ![avatar]( 20210227103224773.png) 

##  2. The filtered point cloud 

 ![avatar]( 20210227103231316.png) 



--------------------------------------------------------------------------------

#  First, the principle of the algorithm 

##  1. Overview 

   Input the downsampling ratio and output the sampling point cloud for the specified sampling ratio. 

##  2. Main functions 

  ```python  
After clicking on the GitHub Sponsor button above, you will obtain access permissions to my private code repository ( https://github.com/slowlon/my_code_bar ) to view this blog code. By searching the code number of this blog, you can find the code you need, code number is: 2024020309574441737
  ```  
    random_down_sample implement random downsampling from the input point cloud to the output point cloud. The sampling index of the sampling point is generated by randomly sampling the index of the input point cloud. 

##  3. Source code interpretation 

 Yes, you read that right!!! The source code of open3d is written C++. 

  ```python  
After clicking on the GitHub Sponsor button above, you will obtain access permissions to my private code repository ( https://github.com/slowlon/my_code_bar ) to view this blog code. By searching the code number of this blog, you can find the code you need, code number is: 2024020309574441737
  ```  
#  Code implementation 

  ```python  
After clicking on the GitHub Sponsor button above, you will obtain access permissions to my private code repository ( https://github.com/slowlon/my_code_bar ) to view this blog code. By searching the code number of this blog, you can find the code you need, code number is: 2024020309574441737
  ```  
#  III. Display of results 

  ```python  
After clicking on the GitHub Sponsor button above, you will obtain access permissions to my private code repository ( https://github.com/slowlon/my_code_bar ) to view this blog code. By searching the code number of this blog, you can find the code you need, code number is: 2024020309574441737
  ```  
 ![avatar]( d0a48c8e577d4c0dbaa04c7454d60d47.png) 



--------------------------------------------------------------------------------

#  First, the principle of the algorithm 

##  1. Overview 

   The random sample consensus algorithm (RANSAC) is an iterative method for calculating the parameters of a mathematical model from a series of data containing divorced values. The RANSAC algorithm essentially consists of two steps, which are continuously looping: (1) randomly select the minimum number of elements that can form a mathematical model from the input data, and use these elements to calculate the parameters of the corresponding model. The selected number of these elements is the minimum number that can determine the parameters of the model. (2) Check which elements in all the data can conform to the model obtained in the first step. Elements that exceed the error threshold are considered outliers, and elements smaller than the error threshold are considered inliers. This process is repeated many times, and the model with the most points is selected to obtain the final result. 

##  2. Fitting plane 

>  RANSAC is specific to the fitting plane in the spatial point cloud: 1. Three points are randomly selected from the point cloud. 2. These three points form a plane. 3. Calculate the distance from all other points to the plane. If it is less than the threshold T, it is considered to be a point in the same plane. 3. If there are more than n points in the same plane, save the plane and mark all points on this plane as matched. 4. The condition for termination is that the plane found after N iterations is less than n points, or three unmarked points cannot be found. 

##  3. Implementation process 

   At present, the most common and simplest method to fit a plane is least squares fitting, but the accuracy of least squares fitting is easily affected by noise. The random sampling consensus algorithm (RANSAC) can eliminate the influence of noise through iterative fitting, and the fitting accuracy is greatly improved. The random sampling consensus algorithm process is shown in Figure 1:1. From the mathematical knowledge, it is known that at least three points are required to fit the plane, so three points are randomly selected first, and then the plane model parameters are calculated according to the plane equation (1). 2. Use the remaining data points to test the plane model estimated in (1), calculate the result error, and compare the error with the set error threshold. If it is less than the set threshold, determine the point as the inner point, and count the number of inner points under the parameter model and record it. 3. Continue with steps 1 and 2. If the number of inner points of the current model is greater than the maximum number of inner points that have been saved, update the model parameters. The retained model parameters are always the model parameters with the largest number of inner points. 4. Repeat steps 1 to 3 and iterate until the iteration threshold is reached. Find the model parameters with the largest number of inner points. Finally, use the inner points to estimate the model parameters again to obtain the final model parameters. 

 ![avatar]( 20210516154607138.png) 

##  4. References 

>  [1] Wang Shaochen. Research on the measurement method of workpiece curved surface profile based on point cloud reconstruction technology [D]. Shandong University, 2020. 

#  Code example 

##  1. Main function 

  ```python  
After clicking on the GitHub Sponsor button above, you will obtain access permissions to my private code repository ( https://github.com/slowlon/my_code_bar ) to view this blog code. By searching the code number of this blog, you can find the code you need, code number is: 2024020309574410380
  ```  
 RANSAC fits a three-dimensional space plane, input parameters: 

 Output parameters: 

##  2. Code implementation 

  ```python  
After clicking on the GitHub Sponsor button above, you will obtain access permissions to my private code repository ( https://github.com/slowlon/my_code_bar ) to view this blog code. By searching the code number of this blog, you can find the code you need, code number is: 2024020309574410380
  ```  
#  III. Display of results 

 ![avatar]( cb07e00639d445a6a92f78b17e88cccd.png) 

 1. Input data 2. Fit results 

  ```python  
After clicking on the GitHub Sponsor button above, you will obtain access permissions to my private code repository ( https://github.com/slowlon/my_code_bar ) to view this blog code. By searching the code number of this blog, you can find the code you need, code number is: 2024020309574410380
  ```  
 ![avatar]( 22847fecf66d47218de011bb274a2317.png) 



--------------------------------------------------------------------------------

#  First, the principle of the algorithm 

##  1. Introduction to the algorithm 

   The RANSAC algorithm, proposed by Fischler and Bolles in 1981, is a method for iteratively and robustly estimating model parameters from data sets. The basic ideas of the algorithm are: continuously randomly select sample sets from the data set to seek model parameters that support more interior points; use the model remainder to test the obtained model parameters; through a certain number of iterations, when the consistency probability of the sampled sample set and the comprehensive understanding is the largest, the sampled sample set is regarded as the comprehensive understanding sample set, and the correctness of the parameter solution is supported by the sample remainder test. The data set contains correct data (inner point inliers) and abnormal data (outer point outliers). The essence of the calculation process of the algorithm is to assume and test: assume that the randomly sampled data are all interior points, use the randomly sampled data to calculate the model parameters; test the estimated model parameters through other points. The RANSAC algorithm requires to ensure that under a certain confidence probability, the minimum number of samples N of its basic subset and the probability of obtaining at least one benign sampling subset satisfy the relationship of equation (1). In the formula: the probability of interior points in the data set, that is, the minimum amount of data required to calculate the model parameters. 

##  2. Straight line fitting 

   The parameter setting of the RANSAC algorithm applied to the fitting of spatial straight lines is as follows: 1) Objective function. The process of maximizing the number of inner points under the model parameters in different iterative processes. The objective function of the RANSAC algorithm applied to the fitting of spatial straight lines is to obtain the parameter model containing the most inner points according to the distance threshold of the known spatial straight line. 2) Sampling subset size. In the iterative calculation process, the model parameters need to be calculated using a subset, and each sampling subset should be the minimum sampling set with the size of the data volume. Spatial straight line fitting requires at least 2 spatial points, so when the RANSAC algorithm is applied to three-dimensional spatial straight line fitting, take. 3) Iteration termination condition. The number of iteration termination of RANSAC can be obtained by theoretical calculation. Under the condition of confidence level, there is at least one sample in the loop process, so that the points of the sampled subset are all interior points, thus ensuring that at least one sample can obtain the maximum value of the objective function in the iteration process. Therefore, from equation (1), the loop termination condition should satisfy the conditional expression (2).  

 ![avatar]( 31a31c45912749bf928d10edbc9ec22a.png) 

   In the formula: the confidence level is generally set to within the range of [95%, 99%]; in general, as the probability of interior points in the data set, it belongs to the unknown parameter. Therefore, the proportion of interior points under the worst condition can be taken, and then the proportion of the current maximum interior points can be continuously updated as the number of iterations increases. The confidence level is generally set to 99%. In summary, the process of using the RANSAC algorithm to solve the geometric parameters of space straight lines is shown in the figure below.  

##  3. References 

>  Bao Jianqiang, Zhang Xianzhou, Li Yuan, Xiao Yuanmiao, Chen Xiao, Luo Chao. Application analysis of various spatial straight line fitting methods [J]. Science of Surveying and Mapping, 2020, 45 (05): 132-139 + 151. 

#  Code implementation 

##  1. Main function 

  ```python  
After clicking on the GitHub Sponsor button above, you will obtain access permissions to my private code repository ( https://github.com/slowlon/my_code_bar ) to view this blog code. By searching the code number of this blog, you can find the code you need, code number is: 2024020309574490550
  ```  
 Find the optimal equation for a three-dimensional straight line. A straight line in three-dimensional space is defined as, but the sum is a vector, not a scalar.  

##  2. Simulation data 

  ```python  
After clicking on the GitHub Sponsor button above, you will obtain access permissions to my private code repository ( https://github.com/slowlon/my_code_bar ) to view this blog code. By searching the code number of this blog, you can find the code you need, code number is: 2024020309574490550
  ```  
##  3. Measured data 

  ```python  
After clicking on the GitHub Sponsor button above, you will obtain access permissions to my private code repository ( https://github.com/slowlon/my_code_bar ) to view this blog code. By searching the code number of this blog, you can find the code you need, code number is: 2024020309574490550
  ```  
#  III. Display of results 

##  1. Simulation data 

 ![avatar]( 7845698f65b24b9eb02b6b3991da1de3.png) 

 1, generative model 2, sampling test data  

 3. Fitting results 

  ```python  
After clicking on the GitHub Sponsor button above, you will obtain access permissions to my private code repository ( https://github.com/slowlon/my_code_bar ) to view this blog code. By searching the code number of this blog, you can find the code you need, code number is: 2024020309574490550
  ```  
 ![avatar]( f633500e0b374da29b53b8c7530d0bdb.png) 

##  2. Measured data 

  ```python  
After clicking on the GitHub Sponsor button above, you will obtain access permissions to my private code repository ( https://github.com/slowlon/my_code_bar ) to view this blog code. By searching the code number of this blog, you can find the code you need, code number is: 2024020309574490550
  ```  
 ![avatar]( e2439ffbb7da4325a0b4ccc221c24f8b.png) 



--------------------------------------------------------------------------------

#  First, the principle of the algorithm 

##  1. Fitting the ball 

   The standard equation for a sphere, the center of the sphere is, the radius is 

##  2. References 

>  [1] PGP2X: Principal Geometric Primitives Parameters Extraction 

#  Code implementation 

##  1. Main function 

  ```python  
After clicking on the GitHub Sponsor button above, you will obtain access permissions to my private code repository ( https://github.com/slowlon/my_code_bar ) to view this blog code. By searching the code number of this blog, you can find the code you need, code number is: 2024020309574413721
  ```  
 The RANSAC algorithm finds the center and radius of a sphere. Input parameters: 

 Output parameters: 

##  2. Complete code 

  ```python  
After clicking on the GitHub Sponsor button above, you will obtain access permissions to my private code repository ( https://github.com/slowlon/my_code_bar ) to view this blog code. By searching the code number of this blog, you can find the code you need, code number is: 2024020309574413721
  ```  
#  III. Display of results 

 ![avatar]( b718d25465c04ac492ca6717d01d36a8.png) 

 1. The original data source 2. The fitting result 

  ```python  
After clicking on the GitHub Sponsor button above, you will obtain access permissions to my private code repository ( https://github.com/slowlon/my_code_bar ) to view this blog code. By searching the code number of this blog, you can find the code you need, code number is: 2024020309574413721
  ```  
 ![avatar]( d49db107b6ed4762af9c54e3c7ad27b9.png) 



--------------------------------------------------------------------------------

#  First, the principle of the algorithm 

   RANSAC fitting circle generally uses three-point fixed circle, but the derivation of the three-point fixed circle calculation formula is too complicated (see: three-point fixed circle derivation formula). Therefore, the method of calculating the circumscribed circle of the triangle is used instead (see: PCL calculates the center and radius of the circumscribed circle of the plane triangle), and the effect is equivalent. 

#  Code implementation 

  ```python  
After clicking on the GitHub Sponsor button above, you will obtain access permissions to my private code repository ( https://github.com/slowlon/my_code_bar ) to view this blog code. By searching the code number of this blog, you can find the code you need, code number is: 2024020309574433490
  ```  
#  III. Display of results 

  ```python  
After clicking on the GitHub Sponsor button above, you will obtain access permissions to my private code repository ( https://github.com/slowlon/my_code_bar ) to view this blog code. By searching the code number of this blog, you can find the code you need, code number is: 2024020309574433490
  ```  
 ![avatar]( 01f0d51e15a1459fa098366c90d76b55.png) 

#  IV. Test data 

  ```python  
After clicking on the GitHub Sponsor button above, you will obtain access permissions to my private code repository ( https://github.com/slowlon/my_code_bar ) to view this blog code. By searching the code number of this blog, you can find the code you need, code number is: 2024020309574433490
  ```  


--------------------------------------------------------------------------------

#  First, the principle of the algorithm 

   The expression of a plane straight line is: at least two points are required, that is, to achieve RANSAC fitting of a two-dimensional straight line. 

#  Code implementation 

  ```python  
After clicking on the GitHub Sponsor button above, you will obtain access permissions to my private code repository ( https://github.com/slowlon/my_code_bar ) to view this blog code. By searching the code number of this blog, you can find the code you need, code number is: 2024020309574425745
  ```  
#  III. Display of results 

  ```python  
After clicking on the GitHub Sponsor button above, you will obtain access permissions to my private code repository ( https://github.com/slowlon/my_code_bar ) to view this blog code. By searching the code number of this blog, you can find the code you need, code number is: 2024020309574425745
  ```  
 ![avatar]( 1b7b306c7f344ba594c6e78a0bf7a9d8.png) 

#  IV. Test data 

  ```python  
After clicking on the GitHub Sponsor button above, you will obtain access permissions to my private code repository ( https://github.com/slowlon/my_code_bar ) to view this blog code. By searching the code number of this blog, you can find the code you need, code number is: 2024020309574425745
  ```  


--------------------------------------------------------------------------------

#  First, the principle of the algorithm 

   The core principle of the algorithm is still RANSAC fitting plane. For the specific theory, please refer to: Open3D uses RANSAC to split the plane. Just slightly modify the code to make it suitable for dividing multiple planes in point cloud data. 

#  Code implementation 

  ```python  
After clicking on the GitHub Sponsor button above, you will obtain access permissions to my private code repository ( https://github.com/slowlon/my_code_bar ) to view this blog code. By searching the code number of this blog, you can find the code you need, code number is: 2024020309574440662
  ```  
#  III. Display of results 

 ![avatar]( b3ab999da9614f60b54a21d79ce93647.png) 

#  IV. Test data 

 Link: https://pan.baidu.com/s/1xdCJ3KyouPCkl6cyKO4a0A Extraction code: ngea 



--------------------------------------------------------------------------------

#  First, the principle of the algorithm 

   The core principle of the algorithm is still the suspicion of RANSAC fitting space. For the specific theory, please refer to: Open3D - RANSAC three-dimensional point cloud space straight line fitting. Just slightly modify the code to make it suitable for dividing multiple straight lines in point cloud data. 

#  Code implementation 

  ```python  
After clicking on the GitHub Sponsor button above, you will obtain access permissions to my private code repository ( https://github.com/slowlon/my_code_bar ) to view this blog code. By searching the code number of this blog, you can find the code you need, code number is: 2024020309574442695
  ```  
#  III. Display of results 

 ![avatar]( c84ef38c74f34a188a0f5b0b50b2509f.png) 

#  IV. Test data 

 Link: https://pan.baidu.com/s/1zCN6Awp7wfK7TAjZsh2PSw Extraction Code: ouym 



--------------------------------------------------------------------------------

